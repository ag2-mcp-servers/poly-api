# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T02:38:04+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field


class License(Enum):
    UNKNOWN = 'UNKNOWN'
    CREATIVE_COMMONS_BY = 'CREATIVE_COMMONS_BY'
    ALL_RIGHTS_RESERVED = 'ALL_RIGHTS_RESERVED'


class Visibility(Enum):
    VISIBILITY_UNSPECIFIED = 'VISIBILITY_UNSPECIFIED'
    PRIVATE = 'PRIVATE'
    UNLISTED = 'UNLISTED'
    PUBLIC = 'PUBLIC'


class Code(Enum):
    CODE_UNSPECIFIED = 'CODE_UNSPECIFIED'
    NO_IMPORTABLE_FILE = 'NO_IMPORTABLE_FILE'
    EMPTY_MODEL = 'EMPTY_MODEL'
    OBJ_PARSE_ERROR = 'OBJ_PARSE_ERROR'
    EXPIRED = 'EXPIRED'
    IMAGE_ERROR = 'IMAGE_ERROR'
    EXTRA_FILES_WITH_ARCHIVE = 'EXTRA_FILES_WITH_ARCHIVE'
    DEFAULT_MATERIALS = 'DEFAULT_MATERIALS'
    FATAL_ERROR = 'FATAL_ERROR'
    INVALID_ELEMENT_TYPE = 'INVALID_ELEMENT_TYPE'


class File(BaseModel):
    contentType: Optional[str] = Field(
        None,
        description='The MIME content-type, such as `image/png`. For more information, see [MIME types](//developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types).',
    )
    relativePath: Optional[str] = Field(
        None,
        description='The path of the resource file relative to the root file. For root or thumbnail files, this is just the filename.',
    )
    url: Optional[str] = Field(
        None, description='The URL where the file data can be retrieved.'
    )


class FormatComplexity(BaseModel):
    lodHint: Optional[int] = Field(
        None,
        description='A non-negative integer that represents the level of detail (LOD) of this format relative to other formats of the same asset with the same format_type. This hint allows you to sort formats from the most-detailed (0) to least-detailed (integers greater than 0).',
    )
    triangleCount: Optional[str] = Field(
        None, description='The estimated number of triangles.'
    )


class Code1(Enum):
    CODE_UNSPECIFIED = 'CODE_UNSPECIFIED'
    INVALID_IMAGE = 'INVALID_IMAGE'
    IMAGE_TOO_BIG = 'IMAGE_TOO_BIG'
    WRONG_IMAGE_TYPE = 'WRONG_IMAGE_TYPE'


class ImageError(BaseModel):
    code: Optional[Code1] = Field(
        None,
        description='The type of image error encountered. Optional for older image errors.',
    )
    filePath: Optional[str] = Field(
        None, description='The file path in the import of the image that was rejected.'
    )


class Code2(Enum):
    CODE_UNSPECIFIED = 'CODE_UNSPECIFIED'
    INCONSISTENT_VERTEX_REFS = 'INCONSISTENT_VERTEX_REFS'
    INVALID_COMMAND = 'INVALID_COMMAND'
    INVALID_NUMBER = 'INVALID_NUMBER'
    INVALID_VERTEX_REF = 'INVALID_VERTEX_REF'
    MISSING_GEOMETRIC_VERTEX = 'MISSING_GEOMETRIC_VERTEX'
    MISSING_TOKEN = 'MISSING_TOKEN'
    TOO_FEW_DIMENSIONS = 'TOO_FEW_DIMENSIONS'
    TOO_FEW_VERTICES = 'TOO_FEW_VERTICES'
    TOO_MANY_DIMENSIONS = 'TOO_MANY_DIMENSIONS'
    UNSUPPORTED_COMMAND = 'UNSUPPORTED_COMMAND'
    UNUSED_TOKENS = 'UNUSED_TOKENS'
    VERTEX_NOT_FOUND = 'VERTEX_NOT_FOUND'
    NUMBER_OUT_OF_RANGE = 'NUMBER_OUT_OF_RANGE'
    INVALID_VALUE = 'INVALID_VALUE'
    INVALID_TEXTURE_OPTION = 'INVALID_TEXTURE_OPTION'
    TOO_MANY_PROBLEMS = 'TOO_MANY_PROBLEMS'
    MISSING_FILE_NAME = 'MISSING_FILE_NAME'
    FILE_NOT_FOUND = 'FILE_NOT_FOUND'
    UNKNOWN_MATERIAL = 'UNKNOWN_MATERIAL'
    NO_MATERIAL_DEFINED = 'NO_MATERIAL_DEFINED'
    INVALID_SMOOTHING_GROUP = 'INVALID_SMOOTHING_GROUP'
    MISSING_VERTEX_COLORS = 'MISSING_VERTEX_COLORS'
    FILE_SUBSTITUTION = 'FILE_SUBSTITUTION'
    LINE_TOO_LONG = 'LINE_TOO_LONG'
    INVALID_FILE_PATH = 'INVALID_FILE_PATH'


class ObjParseError(BaseModel):
    code: Optional[Code2] = Field(
        None, description='The type of problem found (required).'
    )
    endIndex: Optional[int] = Field(
        None, description='The ending character index at which the problem was found.'
    )
    filePath: Optional[str] = Field(
        None, description='The file path in which the problem was found.'
    )
    line: Optional[str] = Field(
        None,
        description='The text of the line. Note that this may be truncated if the line was very long. This may not include the error if it occurs after line truncation.',
    )
    lineNumber: Optional[int] = Field(
        None, description='Line number at which the problem was found.'
    )
    startIndex: Optional[int] = Field(
        None, description='The starting character index at which the problem was found.'
    )


class ColorSpace(Enum):
    UNKNOWN = 'UNKNOWN'
    LINEAR = 'LINEAR'
    GAMMA = 'GAMMA'


class Quaternion(BaseModel):
    w: Optional[float] = Field(None, description='The scalar component.')
    x: Optional[float] = Field(None, description='The x component.')
    y: Optional[float] = Field(None, description='The y component.')
    z: Optional[float] = Field(None, description='The z component.')


class RemixInfo(BaseModel):
    sourceAsset: Optional[List[str]] = Field(
        None,
        description='Resource ids for the sources of this remix, of the form: `assets/{ASSET_ID}`',
    )


class MaxComplexity(Enum):
    COMPLEXITY_UNSPECIFIED = 'COMPLEXITY_UNSPECIFIED'
    COMPLEX = 'COMPLEX'
    MEDIUM = 'MEDIUM'
    SIMPLE = 'SIMPLE'


class FieldXgafv(Enum):
    field_1 = '1'
    field_2 = '2'


class Alt(Enum):
    json = 'json'
    media = 'media'
    proto = 'proto'


class Visibility1(Enum):
    VISIBILITY_UNSPECIFIED = 'VISIBILITY_UNSPECIFIED'
    PUBLISHED = 'PUBLISHED'
    PRIVATE = 'PRIVATE'


class AssetImportMessage(BaseModel):
    code: Optional[Code] = Field(
        None, description='The code associated with this message.'
    )
    filePath: Optional[str] = Field(
        None,
        description='An optional file path. Only present for those error codes that specify it.',
    )
    imageError: Optional[ImageError] = Field(
        None,
        description='An optional image error. Only present for INVALID_IMAGE_FILE.',
    )
    objParseError: Optional[ObjParseError] = Field(
        None,
        description='An optional OBJ parse error. Only present for OBJ_PARSE_ERROR.',
    )


class Format(BaseModel):
    formatComplexity: Optional[FormatComplexity] = Field(
        None, description='Complexity stats about this representation of the asset.'
    )
    formatType: Optional[str] = Field(
        None,
        description='A short string that identifies the format type of this representation. Possible values are: `FBX`, `GLTF`, `GLTF2`, `OBJ`, and `TILT`.',
    )
    resources: Optional[List[File]] = Field(
        None,
        description='A list of dependencies of the root element. May include, but is not limited to, materials, textures, and shader programs.',
    )
    root: Optional[File] = Field(
        None,
        description='The root of the file hierarchy. This will always be populated. For some format_types - such as `TILT`, which are self-contained - this is all of the data. Other types - such as `OBJ` - often reference other data elements. These are contained in the resources field.',
    )


class PresentationParams(BaseModel):
    backgroundColor: Optional[str] = Field(
        None,
        description="A background color which could be used for displaying the 3D asset in a 'thumbnail' or 'palette' style view. Authors have the option to set this background color when publishing or editing their asset. This is represented as a six-digit hexademical triplet specifying the RGB components of the background color, e.g. #FF0000 for Red.",
    )
    colorSpace: Optional[ColorSpace] = Field(
        None,
        description="The materials' diffuse/albedo color. This does not apply to vertex colors or texture maps.",
    )
    orientingRotation: Optional[Quaternion] = Field(
        None,
        description='A rotation that should be applied to the object root to make it upright. More precisely, this quaternion transforms from "object space" (the space in which the object is defined) to "presentation space", a coordinate system where +Y is up, +X is right, -Z is forward. For example, if the object is the Eiffel Tower, in its local coordinate system the object might be laid out such that the base of the tower is on the YZ plane and the tip of the tower is towards positive X. In this case this quaternion would specify a rotation (of 90 degrees about the Z axis) such that in the presentation space the base of the tower is aligned with the XZ plane, and the tip of the tower lies towards +Y. This rotation is unrelated to the object\'s pose in the web preview, which is just a camera position setting and is *not* reflected in this rotation. Please note: this is applicable only to the gLTF.',
    )


class StartAssetImportResponse(BaseModel):
    assetId: Optional[str] = Field(
        None,
        description='The id of newly created asset. If this is empty when the operation is complete it means the import failed. Please refer to the assetImportMessages field to understand what went wrong.',
    )
    assetImportId: Optional[str] = Field(
        None, description='The id of the asset import.'
    )
    assetImportMessages: Optional[List[AssetImportMessage]] = Field(
        None,
        description='The message from the asset import. This will contain any warnings (or - in the case of failure - errors) that occurred during import.',
    )
    publishUrl: Optional[str] = Field(
        None, description='The publish URL for the asset.'
    )


class Asset(BaseModel):
    authorName: Optional[str] = Field(
        None,
        description="The author's publicly visible name. Use this name when giving credit to the author. For more information, see [Licensing](/poly/discover/licensing).",
    )
    createTime: Optional[str] = Field(
        None,
        description='For published assets, the time when the asset was published. For unpublished assets, the time when the asset was created.',
    )
    description: Optional[str] = Field(
        None, description="The human-readable description, set by the asset's author."
    )
    displayName: Optional[str] = Field(
        None, description="The human-readable name, set by the asset's author."
    )
    formats: Optional[List[Format]] = Field(
        None,
        description='A list of Formats where each format describes one representation of the asset.',
    )
    isCurated: Optional[bool] = Field(
        None, description='Whether this asset has been curated by the Poly team.'
    )
    license: Optional[License] = Field(
        None,
        description='The license under which the author has made the asset available for use, if any.',
    )
    metadata: Optional[str] = Field(
        None,
        description="Application-defined opaque metadata for this asset. This field is only returned when querying for the signed-in user's own assets, not for public assets. This string is limited to 1K chars. It is up to the creator of the asset to define the format for this string (for example, JSON).",
    )
    name: Optional[str] = Field(
        None,
        description='The unique identifier for the asset in the form: `assets/{ASSET_ID}`.',
    )
    presentationParams: Optional[PresentationParams] = Field(
        None,
        description='Hints for displaying the asset. Note that these parameters are not immutable; the author of an asset may change them post-publication.',
    )
    remixInfo: Optional[RemixInfo] = Field(
        None, description='The remix info for the asset.'
    )
    thumbnail: Optional[File] = Field(
        None, description='The thumbnail image for the asset.'
    )
    updateTime: Optional[str] = Field(
        None,
        description='The time when the asset was last modified. For published assets, whose contents are immutable, the update time changes only when metadata properties, such as visibility, are updated.',
    )
    visibility: Optional[Visibility] = Field(
        None, description='The visibility of the asset and who can access it.'
    )


class ListAssetsResponse(BaseModel):
    assets: Optional[List[Asset]] = Field(
        None,
        description='A list of assets that match the criteria specified in the request.',
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='The continuation token for retrieving the next page. If empty, indicates that there are no more pages. To get the next page, submit the same request specifying this value as the page_token.',
    )
    totalSize: Optional[int] = Field(
        None, description='The total number of assets in the list, without pagination.'
    )


class ListLikedAssetsResponse(BaseModel):
    assets: Optional[List[Asset]] = Field(
        None,
        description='A list of assets that match the criteria specified in the request.',
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='The continuation token for retrieving the next page. If empty, indicates that there are no more pages. To get the next page, submit the same request specifying this value as the page_token.',
    )
    totalSize: Optional[int] = Field(
        None, description='The total number of assets in the list, without pagination.'
    )


class UserAsset(BaseModel):
    asset: Optional[Asset] = Field(None, description='An Asset.')


class ListUserAssetsResponse(BaseModel):
    nextPageToken: Optional[str] = Field(
        None,
        description='The continuation token for retrieving the next page. If empty, indicates that there are no more pages. To get the next page, submit the same request specifying this value as the page_token.',
    )
    totalSize: Optional[int] = Field(
        None, description='The total number of assets in the list, without pagination.'
    )
    userAssets: Optional[List[UserAsset]] = Field(
        None, description='A list of UserAssets matching the request.'
    )
